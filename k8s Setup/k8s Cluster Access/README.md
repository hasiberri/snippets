# Lainotik Authentication and Authorization in k8s Cluster

In order for the Lainotik platform or any Third Party to access a particular k8s cluster it is requiered to set a proper authentication and authorization for it within the k8s cluster. This is mainly the task of the owner of the k8s cluster, the k8s cluster administrator, and without any doubt, security is the must have requirenment to consider.

In any authentification, several elements take place:

* Client private key
* Client signed certificate
* CA (Certification Authority) certificate

In typical web authentification with TLS, the CA is a well known organization that takes the responsibility to sign client certificates. The CA certificate is available within the most popular browsers (Chrome, Firefox...), in such a way that the browser can verify that the client certificate of a site has been properly signed by the CA. Only this way the browser will consider the access to that site as secure.

In an environment like kubernetes, the goal is not to allow any user to access a k8s cluster. Only a limited well known ammount of people/systems should access it, therefore there is not a real need for a traditional web browser CA authority. Instead, kubernetes itself can take the responsibility to sign the client certificates. How to do this is what will be described here.

Here how all Kubernetes authentication and authorization is setup is explained in detail, describing the steps that need to be followed by the k8s cluster administrator and a Third Party that requires authentication/authorization to the k8s cluster.

## Introduction to certifications management

Kubectl, the "de facto" tool to manage kubernetes platforms, uses a file called kubeconfig to access k8s clusters. By default, this kubeconfig is located under ~/.kube/config. The location of the Kubeconfig can be set through the KUBECONFIG environment variable. In this environment variable several kubeconfig paths can be set separated by ":", being able to switch between them through kubectl. Therefore it is recommended to set the default one and then go adding new ones if needed.

The kubeconfig file requires the following elements to allow kubectl access to a k8s cluster (see the folder examples-kubeconfig):

* IP/Port of the k8s platform API server
* The k8s platform internal CA certificate
* User credentials as private-key/certificates, or a token

When a k8s cluster is setup by the k8s cluster administrator, this includes internally a cluster CA (Certificate Authority). The k8s cluster administrator kubectl is also setup with the admin kubeconfig that includes the admin credentials to access the k8s cluster. These admin credentials are own by the k8s cluster administrator responsible of the k8s cluster, and must be kept safe.

In order for a Third Party to get access, the three elements mentioned above are required, which will be used for the Third Party to create a kubeconfig. Once created, the access for the Third Party to the k8s cluster will be available with the proper authentication and authorization. Therefore, here two actors have their play, the k8s cluster administrator (responsible for the k8s cluster) and the Third Party that requires access to the k8s cluster (Lainotik platform for example).

This document will provide a full description of how to setup authentication and authorization based on private key/certificates for a Third Party by the k8s cluster administrator.  For this, it will be considered the user name as "admin", and the name of the k8s cluster as "mykube". To facilitate the description a set of yaml templates are provided that will be mentioned accross the whole description:

* templates/lainotik-cr.yaml
* templates/lainotik-crb.yaml
* templates/lainotik-csr.yaml

Additionally serveral shell scripts have been created to faciliate the work:

* clientkeycsr-build.sh
* clientcacrt-build.sh
* clientkubeconfig-build.sh

The use of this templates and scripts will be explained accross the whole description. Note that the certification files generated by the scripts will be stored under /certs folder, while the k8s manifests will be stored under /manifests folder. Let's start!!!

## Create key and credential signing request (Third Party)

In all this process, the first step is to be taken by the Third Party, who creates a private key and a certificate signing request (CSR). This can be done using openssl or any other similar tool:

```shell
$ openssl req -new -newkey rsa:4096 -nodes -keyout client.key -out client.csr -subj "/CN=admin /O=admingroup"
```

WARNING: Keeping the client.key (the private key) safe is really critical. If this is in the open, then there is a risk that other than the Third Party could access the k8s cluster, so be carefull. Note: Everytime this openssl command is run a different key and CSR is generated. 

In order to help in the testing, here a few more uses of openssl that allow getting the public key from a private key, from a CSR, and from a client certificate:

```shell
$ openssl req -in certs/client.csr -noout -pubkey -out clientcsr.pub
$ openssl rsa -in certs/client.key -pubout > clientkey.pub
$ openssl x509 -pubkey -noout -in certs/client.crt  > clientcrt.pub
```

Note that, if everything is completed correctly, the three commands must generate the same public key. As expected, applying this openssl commands it can verified that the public key obtained from the client key and the CSR is the same.

The common Name (CN) and organization (O) parameters are very important. As will be shown later, Kubernetes uses the Common Name (CN) to match the client certificate with the user name in the RoleBinding and uses the Organization (O) to match the group in the RoleBinding. As with the public key, through openssl it is possible to obtain the CN and O from the private key, CSR, and client certificate:

```shell
$ openssl req -in certs/client.csr -noout -subject
$ openssl rsa -in certs/client.key -subject
$ openssl x509 -subject -noout -in certs/client.crt
```

Considering all this, the only thing to do by the Third Party is to generate a CSR and provide it to k8s cluster administrator, keeping the private key in a save place. To facilitate these step, the following shell script can be applied to generate the client private key and the CSR, providing as parameters the CN and O, which in our description will be admin and admingroup:

```shell
$ ./client-csr-build.sh admin admingroup
```
## Obtaining the signed certificates (k8s Cluster Administrator)

The CSR needs to be signed through the cluster CA in order to obtain the client certificate. For that, as a first step, a CertificateSigningRequest object must be created in the k8s cluster with the CSR. As the k8s cluster administrator is the only one that has access to the k8s cluster with Kubectl in the first place, this can only be done by him/her. IMPORTANT: Overwriting this object does not work, therefore before creating the object make sure to delete it first if exists (the name of this object in this description will be lainotik-admin-csr), which is the name used within the lainotik-csr.yaml template:

```shell
$ kubectl get csr
$ kubectl delete csr lainotik-admin-csr
```

The k8s cluster administrator should be applying the lainotik-csr.yaml template to create the CertificateSigningRequest object in the k8s cluster, in which the base64 output of the CSR must be included under the requests field. Therefore, as the first step, the Third Party must provide the CSR to the k8s cluster administrator (not the private key, keep it save), who them will set and apply the lainotik-csr.yaml as follows:

```shell
$ openssl req -in certs/client.csr -noout -subject      # Get CN in CSR. Copy it within lainotik-csr.yaml
$ cat certs/client.csr | base64 | tr -d '\n'            # Get the base64 CSR. Copy it within lainotik-csr.yaml, in the request field
$ kubectl apply -f lainotik-csr.yaml
$ kubectl get csr                                       # To check
```
Once applied the yaml, the CertificateSigningRequest object within the k8s cluster will be in condition "Pending". This means that this object is pending to be approved by the k8s cluster administrator responsible for the k8s cluster before it is signed. To approve it, the following command must be applied:

```shell
$ kubectl certificate approve lainotik-admin-csr
```
After this, the condition of the object will change to "Aproved/Issued". This is the "signal" to indicate that the client certificate signing request has been completed and that there is a client certificate available that can be used with the original client private key to access the k8s cluster. In order to get the newly created client certificate, the k8s cluster administrator can apply the following command:

```shell
$ kubectl get csr lainotik-admin-csr -o jsonpath='{.status.certificate}' | base64 --decode > client.crt
```

Checking the obtained CRT file we can confirm that it is actually a certificate, and with openssl it can be confirmed that it carries the same public key as the original CSR. Once the client certificate is obtained, the only thing missing is the CA certificate of the k8s cluster. The k8s cluster administrator can also obtain this through the following command:

```shell
$ cat $(kubectl config view -o jsonpath='{.clusters[0].cluster.certificate-authority}') > ca.crt
```

With the client.crt and the ca.crt available, it is just a matter of providing both to the Third Party, together with the IP address of the k8s cluster.

## Assigment of roles (k8s Cluster Administrator)

Having the key and the certificates gives the Third Party authentication access to the k8s cluster, but still it is necessary to define the authorization to this Third Party within the k8s cluster. Authorization defines the objects the Third Party can play with within the k8s cluster.

Here K8s RBAC (Role-based access control) is what takes place. In RBAC, roles are scoped to either the entire cluster via a ClusterRole object or to a particular namespace via a Role object. Setting the RBAC access control for the Third party is again a task for the k8s cluster administrator.

The goal here is to provide to the new user, the Third Party, proper authorization to operate within the k8s cluster. The way it works is as follows: First, the k8s cluster administrator must create a role object in the k8s cluster (clusterRole or namespace Role) with the right authorization, and after, this role should be assigned to the Third Party user by means of a role binding object.

The following k8s templates have been defined to get a better idea of how to use the role and binding process. Here a clusterRole is considered for the Third Party:

* lainotik-cr.yaml (to create a cluster role with the corresponding authorization)
* lainotik-crb.yaml (to create a cluster role binding with the user)

To facilitate the understanding, all the process to create a CertificateSigningRequest object, obtain the certificates and set the RBAC has been defined within a shell script:

```shell
$ ./client-crt-build.sh
```

## Setting Kubeconfig and accessing the platform (Third Party)

Once the Third Party gets the client.crt and the ca.crt from the k8s cluster administrator, it is a matter of creating a kubeconfig with them. Note that the Third Party must have have the client.key, which as mentioned already, must be kept safe. Without this private key the access to the k8s cluster will not be allowed.

A Kubeconfig has three sections, cluster, credentials and context. Here the steps to create it through kubectl commands:

Set the cluster:

```shell
$ kubectl config set-cluster $(kubectl config view -o jsonpath='{.clusters[0].name}') --server=$(kubectl config view -o jsonpath='{.clusters[0].cluster.server}') --certificate-authority=certs/ca.crt --kubeconfig=manifests/lainotik-config.yaml --embed-certs
```

Set credentials (certificate and keys) for the new user:

```shell
$ kubectl config set-credentials admin --client-certificate=certs/client.crt --client-key=certs/client.key --embed-certs --kubeconfig=manifests/lainotik-config.yaml
```

Add context:

```shell
$ kubectl config set-context admin-mykube --cluster=$(kubectl config view -o jsonpath='{.clusters[0].name}') --user=admin --kubeconfig=manifests/lainotik-config.yaml
```

Set this newly created context as the one to be used:
```shell
$ kubectl config use-context lainotik-mykube --kubeconfig=manifests/lainotik-config.yaml
```
All this can be done using a template yaml. For this description and as an example check templates/lainotik-config.yaml. Note that in this commands, and in the yaml itself, a reference to the key/certs files is used. Instead it is posible to embed base64 coded data of the key/certs in the yaml itself. Depending on wheter the files or the base64 data is used, the parameter should be called "certificate-authority" or "certificate-authority-data" respectively. In this description we have assumed that file references are used.

Finally just test that the authorization/authentication has been set properly:

```shell
$ kubectl version --kubeconfig=manifests/lainotik-config.yaml
```

Then any Kubectl command can be tried, like these ones:
```shell
$ kubectl get namespaces --kubeconfig=manifests/lainotik-config.yaml
$ kubectl get pods --kubeconfig=manifests/lainotik-config.yaml
$ kubectl get services --kubeconfig=manifests/lainotik-config.yaml
$ ...
```

It might happen that the commands do not work because the action is forbidden. Note that this is due to the RBAC authorization settings for the clusterRole done previously by the k8s cluster manager. Modify the clusterRole options in lainotik-crb.yaml as needed to make the kubectl commands work. Note that the right authorization, as limited as posible, must be set for the specific clusterRole in order to enforce security.

To facilitate the understanding, all the process to create a kubeconfig as been defined in a shell script (the ip is a ficticious one representing the k8s cluster ip):

```shell
$ ./client-kubeconfig-build.sh mykube 192.168.99.107
```

